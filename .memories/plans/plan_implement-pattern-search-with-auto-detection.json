{
  "content": "## Goal\nAdd code idiom search to Miller with smart auto-detection, enabling searches for patterns like `ILogger<`, `: BaseClass`, `[Fact]`.\n\n## Status: Ready to Implement (POC Validated \u2705)\n\n## Context\n- **POC validated**: Whitespace tokenizer + phrase search works perfectly\n- **Tool design decided**: Option C (auto-detection with override)\n- **Fallback pattern**: Consider text \u2192 semantic fallback (Julie pattern)\n\n---\n\n## Implementation Plan\n\n### Phase 1: Add Pattern Field & Index (4-6 hours)\n\n**1.1 Update LanceDB Schema** (1 hour)\n```python\n# In embeddings.py:130-142\nSCHEMA = pa.schema([\n    # ... existing fields ...\n    pa.field(\"code_pattern\", pa.string(), nullable=False),  # NEW\n    # ... vector field ...\n])\n```\n\n**1.2 Populate Pattern Field** (2 hours)\n```python\n# In embeddings.py:205-247 (add_symbols)\ndef add_symbols(self, symbols: List[Any], vectors: np.ndarray) -> int:\n    for sym, vec in zip(symbols, vectors):\n        # Build pattern-preserving content\n        pattern_parts = []\n        if sym.signature:\n            pattern_parts.append(sym.signature)\n        pattern_parts.append(sym.name)\n        if sym.kind:\n            pattern_parts.append(sym.kind)\n        \n        code_pattern = \" \".join(pattern_parts)\n        \n        data.append({\n            # ... existing fields ...\n            \"code_pattern\": code_pattern,  # NEW\n            # ...\n        })\n```\n\n**1.3 Create Whitespace FTS Index** (1 hour)\n```python\n# In embeddings.py:179-203 (_create_fts_index)\ndef _create_fts_index(self):\n    # Create whitespace-tokenized index on pattern field\n    self._table.create_fts_index(\n        [\"code_pattern\"],  # Pattern field only\n        use_tantivy=True,\n        base_tokenizer=\"whitespace\",  # Preserves : < > [ ] ( )\n        with_position=True,\n        replace=True\n    )\n    self._fts_index_created = True\n```\n\n**1.4 Add Pattern Search Method** (1-2 hours)\n```python\n# In embeddings.py:VectorStore - add new method\ndef _search_pattern(self, query: str, limit: int) -> List[Dict]:\n    \"\"\"Search code patterns using whitespace-tokenized field.\"\"\"\n    from lancedb.query import MatchQuery\n    \n    # Auto-wrap in quotes for phrase search (handles special chars)\n    if not query.startswith('\"'):\n        query = f'\"{query}\"'\n    \n    results = (\n        self._table\n        .search(MatchQuery(query, \"code_pattern\"), query_type=\"fts\")\n        .limit(limit)\n        .to_list()\n    )\n    \n    # Normalize scores\n    if results:\n        max_score = max(r.get(\"_score\", 0.0) for r in results)\n        for r in results:\n            raw_score = r.get(\"_score\", 0.0)\n            r[\"score\"] = raw_score / max_score if max_score > 0 else 0.0\n    \n    return results\n```\n\n---\n\n### Phase 2: Auto-Detection Logic (2-3 hours)\n\n**2.1 Query Type Detection** (1 hour)\n```python\n# In embeddings.py or search_utils.py\ndef detect_search_method(query: str) -> str:\n    \"\"\"\n    Detect optimal search method from query characteristics.\n    \n    Returns: \"pattern\" | \"hybrid\"\n    \"\"\"\n    # Code pattern indicators\n    pattern_chars = [':', '<', '>', '[', ']', '(', ')', '{', '}']\n    \n    # Check for code patterns\n    if any(ch in query for ch in pattern_chars):\n        return \"pattern\"\n    \n    # Default to hybrid (best quality for general search)\n    return \"hybrid\"\n```\n\n**2.2 Update VectorStore.search()** (1-2 hours)\n```python\n# In embeddings.py:249-274 (search method)\ndef search(\n    self,\n    query: str,\n    method: Literal[\"auto\", \"text\", \"pattern\", \"semantic\", \"hybrid\"] = \"auto\",\n    limit: int = 50\n) -> List[Dict]:\n    \"\"\"\n    Search symbols by query with auto-detection.\n    \n    Args:\n        query: Search query\n        method: Search method (auto/text/pattern/semantic/hybrid)\n        limit: Maximum results\n        \n    Returns:\n        List of dicts with symbol metadata + score\n    \"\"\"\n    if self._table is None:\n        return []\n    \n    # Auto-detect if needed\n    if method == \"auto\":\n        method = detect_search_method(query)\n    \n    # Route to appropriate search\n    if method == \"pattern\":\n        return self._search_pattern(query, limit)\n    elif method == \"text\":\n        return self._search_text(query, limit)\n    elif method == \"semantic\":\n        return self._search_semantic(query, limit)\n    else:  # hybrid\n        return self._search_hybrid(query, limit)\n```\n\n---\n\n### Phase 3: Fallback Logic (Optional - 1-2 hours)\n\n**Julie's Pattern**: If text search returns 0 results \u2192 try semantic\n\n```python\ndef search(self, query: str, method: str = \"auto\", limit: int = 50):\n    # ... detection logic ...\n    \n    results = []\n    \n    # Primary search\n    if method == \"pattern\":\n        results = self._search_pattern(query, limit)\n    elif method == \"text\":\n        results = self._search_text(query, limit)\n    # ... etc\n    \n    # Fallback: If text/pattern returns nothing, try semantic\n    if len(results) == 0 and method in [\"text\", \"pattern\"]:\n        logger.info(f\"Primary search ({method}) returned 0 results, falling back to semantic\")\n        results = self._search_semantic(query, limit)\n        \n        # Add metadata indicating fallback\n        for r in results:\n            r[\"_fallback\"] = True\n            r[\"_fallback_reason\"] = f\"{method} \u2192 semantic (0 results)\"\n    \n    return results\n```\n\n**Note**: May not need this if Tantivy FTS is good enough!\n\n---\n\n### Phase 4: Update MCP Tool (1 hour)\n\n**4.1 Update fast_search Tool**\n```python\n# In server.py:165-200\ndef fast_search(\n    query: str,\n    method: Literal[\"auto\", \"text\", \"pattern\", \"semantic\", \"hybrid\"] = \"auto\",\n    limit: int = 50\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Search codebase using text, semantic, or hybrid methods.\n    \n    Method selection (default: auto):\n    - auto: Detects query type automatically\n      * Has special chars (: < > [ ]) \u2192 pattern search (code idioms)\n      * Natural language \u2192 hybrid search (text + semantic)\n    - text: Full-text search with stemming (general code search)\n    - pattern: Code idioms (: BaseClass, ILogger<, [Fact], etc.)\n    - semantic: Vector similarity (conceptual matches)\n    - hybrid: Combines text + semantic with RRF fusion\n    \n    Examples:\n        # Auto-detection (recommended)\n        fast_search(\"authentication logic\")        # Auto: hybrid\n        fast_search(\": BaseClass\")                 # Auto: pattern\n        fast_search(\"ILogger<UserService>\")        # Auto: pattern\n        fast_search(\"[Fact]\")                      # Auto: pattern\n        \n        # Manual override\n        fast_search(\"map<int, string>\", method=\"text\")  # Force text\n        fast_search(\"user auth\", method=\"semantic\")     # Force semantic\n    \n    Args:\n        query: Search query (code, patterns, or natural language)\n        method: Search method (auto-detects by default)\n        limit: Maximum results to return\n        \n    Returns:\n        List of matching symbols with scores and metadata\n    \"\"\"\n    # Delegate to vector store (handles auto-detection)\n    return vector_store.search(query, method, limit)\n```\n\n---\n\n### Phase 5: Testing (3 hours)\n\n**5.1 Unit Tests** (1 hour)\n- Test pattern field creation\n- Test whitespace tokenizer preserves special chars\n- Test phrase wrapping logic\n- Test auto-detection heuristic\n\n**5.2 Integration Tests** (1 hour)\n- Test end-to-end: index C# code \u2192 search for `: BaseClass`\n- Test end-to-end: index C# code \u2192 search for `ILogger<`\n- Test end-to-end: index C# code \u2192 search for `[Fact]`\n- Test fallback logic (if implemented)\n\n**5.3 Real-World Testing** (1 hour)\n- Index Miller itself\n- Index Julie codebase\n- Test patterns:\n  - `: BaseService` (inheritance)\n  - `ILogger<` (generics)\n  - `?.` (null-conditional)\n  - `=>` (lambda)\n- Measure accuracy (>95% target)\n\n---\n\n### Phase 6: Documentation (1-2 hours)\n\n**6.1 Update Tool Descriptions**\n- Add pattern search examples to `fast_search` docstring\n- Document auto-detection behavior\n- Show when to override with `method=`\n\n**6.2 Update README**\n- Add \"Code Idiom Search\" section\n- Show examples of pattern queries\n- Explain auto-detection\n\n**6.3 Update PLAN.md**\n- Mark pattern search as implemented\n- Document architecture decisions\n\n---\n\n## Success Criteria\n\nBefore marking complete:\n\n- \u2705 Can search for `: BaseClass` and find all inheritance\n- \u2705 Can search for `ILogger<` and find all generic usages\n- \u2705 Can search for `[Fact]` and find all test attributes\n- \u2705 Auto-detection works >95% of time\n- \u2705 Manual override available for edge cases\n- \u2705 Performance <100ms (no regression)\n- \u2705 Tests cover 15+ code idiom patterns\n- \u2705 Documentation with clear examples\n\n---\n\n## Timeline\n\n- **Phase 1**: 4-6 hours (pattern field + index)\n- **Phase 2**: 2-3 hours (auto-detection)\n- **Phase 3**: 1-2 hours (fallback - optional)\n- **Phase 4**: 1 hour (MCP tool)\n- **Phase 5**: 3 hours (testing)\n- **Phase 6**: 1-2 hours (docs)\n\n**Total**: 12-17 hours (with fallback), 11-15 hours (without)\n\n---\n\n## Open Questions\n\n1. **Fallback logic**: Implement text\u2192semantic fallback or wait to see if Tantivy FTS is good enough?\n   - **Decision**: Start without, add if needed after testing\n\n2. **Pattern detection heuristic**: Just check for special chars or more sophisticated?\n   - **Decision**: Start simple (special char check), refine if needed\n\n3. **Phrase wrapping**: Always wrap pattern queries or only if not already wrapped?\n   - **Decision**: Check if already wrapped, wrap if needed (defensive)\n\n---\n\n## References\n\n- **POC Test**: `python/tests/test_pattern_search_poc.py` (all tests passing \u2705)\n- **Research Doc**: `docs/TANTIVY_LANCEDB_RESEARCH.md`\n- **Tool Design**: `docs/SEARCH_TOOL_DESIGN.md`\n- **Analysis**: `docs/SEARCH_FOUNDATION_ANALYSIS.md`\n- **COA Reference**: `~/source/coa-codesearch-mcp/` (proven patterns)\n\n---\n\n## Implementation Notes\n\n- Pattern field uses whitespace tokenizer (preserves all special chars)\n- Phrase search (quotes) required to avoid Tantivy syntax errors\n- Auto-detection checks for: `: < > [ ] ( ) { }`\n- Fallback logic is optional (may not need with good FTS)\n- One tool (`fast_search`), minimal context overhead\n\n---\n\n**Ready to implement!**\n",
  "git": {
    "branch": "main",
    "commit": "a437e91",
    "dirty": true,
    "files_changed": [
      ".memories/plans/plan_implement-checkpointrecallplan-tools-in-miller-julie-compatible.json",
      ".memories/2025-11-18/124215_de9a.json",
      ".memories/2025-11-18/124348_36fc.json",
      ".memories/2025-11-18/125434_fede.json",
      ".memories/2025-11-18/132517_615f.json",
      ".memories/2025-11-18/140635_54de.json",
      ".memories/2025-11-18/141302_e014.json",
      "docs/SEARCH_FOUNDATION_ANALYSIS.md",
      "docs/SEARCH_TOOL_DESIGN.md",
      "docs/TANTIVY_LANCEDB_RESEARCH.md",
      "python/tests/test_pattern_search_poc.py"
    ]
  },
  "id": "plan_implement-pattern-search-with-auto-detection",
  "status": "active",
  "timestamp": 1763500204,
  "title": "Implement Pattern Search with Auto-Detection",
  "type": "plan"
}
