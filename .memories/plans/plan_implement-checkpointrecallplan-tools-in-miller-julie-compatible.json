{
  "id": "plan_implement-checkpointrecallplan-tools-in-miller-julie-compatible",
  "timestamp": 1763488903,
  "type": "plan",
  "title": "Implement checkpoint/recall/plan tools in Miller (Julie-compatible)",
  "status": "active",
  "content": "## Goal\nImplement checkpoint, recall, and plan MCP tools in Miller with 100% backward compatibility with Julie's .memories system, enabling dogfooding Miller to replace Julie.\n\n## Success Criteria\n- ✅ Same JSON schema as Julie (all fields, types match exactly)\n- ✅ Same file naming (HHMMSS_XXXX.json format)\n- ✅ Same directory structure (.memories/YYYY-MM-DD/, .memories/plans/)\n- ✅ Same ID format ({type}_{8hex}_{6hex})\n- ✅ Same git context capture (branch, commit, dirty, files_changed)\n- ✅ Can read existing Julie checkpoints\n- ✅ Julie can read Miller checkpoints\n- ✅ All tests passing (TDD methodology)\n\n---\n\n## Phase 1: Test Design (RED - Write Failing Tests First)\n\n### 1.1 Create test file structure\n- [ ] Create `python/tests/test_memory_tools.py`\n- [ ] Add pytest fixtures for temp .memories directory\n- [ ] Add fixtures for mock git context\n\n### 1.2 Checkpoint tool tests\n- [ ] `test_checkpoint_creates_file_in_correct_location()`\n  - Verify .memories/YYYY-MM-DD/HHMMSS_XXXX.json created\n- [ ] `test_checkpoint_json_schema_matches_julie()`\n  - Verify all required fields present\n  - Verify field types match (id: str, timestamp: int, etc.)\n- [ ] `test_checkpoint_generates_unique_id_format()`\n  - Verify format: `{type}_{8hex}_{6hex}`\n  - Verify uniqueness across multiple calls\n- [ ] `test_checkpoint_captures_git_context()`\n  - Verify branch, commit, dirty, files_changed captured\n- [ ] `test_checkpoint_supports_all_memory_types()`\n  - Test: checkpoint, decision, learning, observation\n- [ ] `test_checkpoint_handles_tags()`\n  - Verify tags stored as array\n  - Verify lowercase, hyphenated format\n- [ ] `test_checkpoint_returns_checkpoint_id()`\n  - Verify tool returns generated ID\n- [ ] `test_checkpoint_file_is_pretty_printed()`\n  - Verify JSON indent=2, sorted keys\n\n### 1.3 Recall tool tests\n- [ ] `test_recall_returns_recent_first()`\n  - Create 5 checkpoints, verify reverse chronological order\n- [ ] `test_recall_filters_by_type()`\n  - Create mixed types, filter for \"decision\", verify only decisions returned\n- [ ] `test_recall_filters_by_since_date()`\n  - Verify since=\"2025-01-01\" returns only after that date\n- [ ] `test_recall_filters_by_until_date()`\n  - Verify until=\"2025-01-31\" returns only before that date\n- [ ] `test_recall_respects_limit()`\n  - Create 20 checkpoints, limit=10, verify only 10 returned\n- [ ] `test_recall_reads_julie_checkpoints()`\n  - Copy actual Julie checkpoint, verify recall can read it\n- [ ] `test_recall_handles_empty_memories()`\n  - Verify returns [] when no checkpoints exist\n\n### 1.4 Plan tool tests\n- [ ] `test_plan_save_creates_file()`\n  - Verify .memories/plans/plan_{slug}.json created\n- [ ] `test_plan_generates_slug_from_title()`\n  - \"Add Search\" → \"plan_add-search\"\n  - \"Fix Bug #123\" → \"plan_fix-bug-123\"\n- [ ] `test_plan_save_auto_activates_by_default()`\n  - Verify status=\"active\" after save with activate=True\n- [ ] `test_plan_list_returns_all_plans()`\n  - Create 3 plans, verify list returns all\n- [ ] `test_plan_list_filters_by_status()`\n  - Create active/complete plans, filter, verify correct subset\n- [ ] `test_plan_activate_deactivates_others()`\n  - Create 2 active plans, activate 3rd, verify only 3rd is active\n- [ ] `test_plan_update_modifies_content()`\n  - Create plan, update content, verify content changed\n- [ ] `test_plan_complete_sets_timestamp()`\n  - Create plan, complete it, verify completed_at set\n- [ ] `test_plan_get_retrieves_by_id()`\n  - Create plan, get by ID, verify correct plan returned\n\n---\n\n## Phase 2: Implementation (GREEN - Minimal Code to Pass Tests)\n\n### 2.1 Create memory utilities module\n- [ ] Create `python/miller/memory_utils.py`\n- [ ] Implement `generate_checkpoint_id(type: str) -> str`\n- [ ] Implement `generate_checkpoint_filename() -> str`\n- [ ] Implement `get_checkpoint_path(timestamp: int) -> Path`\n- [ ] Implement `get_git_context() -> dict`\n- [ ] Implement `slugify_title(title: str) -> str`\n\n### 2.2 Implement checkpoint tool\n- [ ] Add `checkpoint()` function in `python/miller/tools/memory.py`\n- [ ] Parameters: description, tags=None, type=\"checkpoint\"\n- [ ] Capture git context automatically\n- [ ] Generate unique ID and filename\n- [ ] Create .memories/YYYY-MM-DD/ directory if needed\n- [ ] Write pretty-printed JSON (indent=2, sort_keys=True)\n- [ ] Return checkpoint ID\n\n### 2.3 Implement recall tool\n- [ ] Add `recall()` function in `python/miller/tools/memory.py`\n- [ ] Parameters: type=None, since=None, until=None, limit=10\n- [ ] Scan .memories/YYYY-MM-DD/ directories\n- [ ] Parse JSON files\n- [ ] Filter by type/date if specified\n- [ ] Sort by timestamp descending\n- [ ] Return list of checkpoint dicts\n\n### 2.4 Implement plan tool\n- [ ] Add `plan()` function in `python/miller/tools/memory.py`\n- [ ] Support actions: save, get, list, activate, update, complete\n- [ ] Implement slug generation for plan IDs\n- [ ] Implement single-active-plan enforcement\n- [ ] Create .memories/plans/ directory if needed\n- [ ] Write pretty-printed JSON\n\n### 2.5 Register MCP tools\n- [ ] Add @mcp.tool() decorator for checkpoint in server.py\n- [ ] Add @mcp.tool() decorator for recall in server.py\n- [ ] Add @mcp.tool() decorator for plan in server.py\n- [ ] Add proper docstrings (MCP displays these to users)\n\n---\n\n## Phase 3: Backward Compatibility Validation\n\n### 3.1 Cross-compatibility tests\n- [ ] `test_miller_reads_julie_checkpoints()`\n  - Copy 5 actual Julie checkpoints\n  - Verify Miller's recall() can read them\n- [ ] `test_julie_reads_miller_checkpoints()` (manual verification)\n  - Create checkpoint with Miller\n  - Verify Julie can read it (test in Julie)\n- [ ] `test_miller_reads_julie_plans()`\n  - Copy actual Julie plan file\n  - Verify Miller can read/update/complete it\n- [ ] `test_checkpoint_schema_exact_match()`\n  - Compare Miller checkpoint JSON to Julie checkpoint JSON\n  - Verify byte-for-byte identical structure (minus content)\n\n### 3.2 Edge cases\n- [ ] `test_handles_missing_memories_directory()`\n  - Verify tools create .memories/ if it doesn't exist\n- [ ] `test_handles_corrupt_json_gracefully()`\n  - Place invalid JSON in .memories/, verify recall doesn't crash\n- [ ] `test_handles_unicode_in_description()`\n  - Create checkpoint with emoji, Chinese chars, etc.\n- [ ] `test_handles_long_descriptions()`\n  - Create checkpoint with 10,000 char description\n\n---\n\n## Phase 4: Integration & Documentation\n\n### 4.1 Integration tests\n- [ ] `test_checkpoint_recall_round_trip()`\n  - Create checkpoint, immediately recall, verify data matches\n- [ ] `test_plan_full_lifecycle()`\n  - save → get → update → activate → complete, verify all work\n- [ ] `test_concurrent_checkpoints()`\n  - Create 10 checkpoints rapidly, verify all unique IDs/filenames\n\n### 4.2 Documentation\n- [ ] Update server.py tool docstrings with examples\n- [ ] Add memory tools section to README.md\n- [ ] Document .memories/ structure in PLAN.md\n- [ ] Add usage examples to docs/\n\n### 4.3 Performance validation\n- [ ] Benchmark recall with 1000 checkpoints (should be <100ms)\n- [ ] Verify checkpoint creation is <50ms\n- [ ] Test with large descriptions (1MB text)\n\n---\n\n## Implementation Notes\n\n**File: `python/miller/memory_utils.py`**\n```python\nimport secrets\nfrom datetime import datetime\nfrom pathlib import Path\nimport subprocess\nimport json\n\ndef generate_checkpoint_id(type: str) -> str:\n    \\\"\\\"\\\"Generate checkpoint ID: {type}_{8hex}_{6hex}\\\"\\\"\\\"\n    rand1 = secrets.token_hex(4)  # 8 hex chars\n    rand2 = secrets.token_hex(3)  # 6 hex chars\n    return f\"{type}_{rand1}_{rand2}\"\n\ndef generate_checkpoint_filename() -> str:\n    \\\"\\\"\\\"Generate filename: HHMMSS_XXXX.json\\\"\\\"\\\"\n    now = datetime.now()\n    time_str = now.strftime(\"%H%M%S\")\n    random_suffix = secrets.token_hex(2)  # 4 hex chars\n    return f\"{time_str}_{random_suffix}.json\"\n\ndef get_checkpoint_path(timestamp: int) -> Path:\n    \\\"\\\"\\\"Get path for checkpoint file.\\\"\\\"\\\"\n    dt = datetime.fromtimestamp(timestamp)\n    date_dir = dt.strftime(\"%Y-%m-%d\")\n    filename = generate_checkpoint_filename()\n    return Path(\".memories\") / date_dir / filename\n\ndef get_git_context() -> dict:\n    \\\"\\\"\\\"Capture current git state.\\\"\\\"\\\"\n    # Implementation details...\n    pass\n```\n\n**File: `python/miller/tools/memory.py`**\n```python\nfrom fastmcp import Context\nfrom pathlib import Path\nimport json\nfrom datetime import datetime\nfrom typing import List, Dict, Any, Optional\n\nasync def checkpoint(\n    ctx: Context,\n    description: str,\n    tags: Optional[List[str]] = None,\n    type: str = \"checkpoint\"\n) -> str:\n    \\\"\\\"\\\"Create immutable development memory checkpoint.\\\"\\\"\\\"\n    # Implementation...\n    pass\n\nasync def recall(\n    ctx: Context,\n    type: Optional[str] = None,\n    since: Optional[str] = None,\n    until: Optional[str] = None,\n    limit: int = 10\n) -> List[Dict[str, Any]]:\n    \\\"\\\"\\\"Retrieve development memory checkpoints.\\\"\\\"\\\"\n    # Implementation...\n    pass\n\nasync def plan(\n    ctx: Context,\n    action: str,\n    title: Optional[str] = None,\n    content: Optional[str] = None,\n    id: Optional[str] = None,\n    status: Optional[str] = None,\n    activate: bool = True\n) -> Any:\n    \\\"\\\"\\\"Manage mutable development plans.\\\"\\\"\\\"\n    # Implementation...\n    pass\n```\n\n---\n\n## Testing Strategy\n\n**Test execution order (TDD):**\n1. Write all tests in Phase 1 (expect ALL to fail - RED)\n2. Implement utilities in Phase 2.1 (some tests pass - GREEN)\n3. Implement checkpoint in Phase 2.2 (checkpoint tests pass)\n4. Implement recall in Phase 2.3 (recall tests pass)\n5. Implement plan in Phase 2.4 (plan tests pass)\n6. Run backward compat tests in Phase 3 (all pass - VALIDATE)\n7. Integration tests in Phase 4 (full system works)\n\n**Coverage target:** 95%+ on memory_utils.py and tools/memory.py\n\n---\n\n## Dependencies\n\nNo new dependencies required! Uses stdlib:\n- `pathlib` - File operations\n- `json` - JSON serialization\n- `datetime` - Timestamps\n- `secrets` - Cryptographically secure random IDs\n- `subprocess` - Git commands\n\n---\n\n## Risks & Mitigations\n\n**Risk:** Git context capture fails on systems without git\n**Mitigation:** Graceful fallback - capture what's available, set missing fields to defaults\n\n**Risk:** Concurrent checkpoint creation could collide on filename\n**Mitigation:** Random suffix in filename (4 hex chars = 65,536 possibilities per second)\n\n**Risk:** Large .memories/ directory slows recall\n**Mitigation:** Optimize by only scanning date directories in range, add caching if needed\n\n---\n\n## Timeline Estimate\n\n- Phase 1 (Tests): 2-3 hours (write comprehensive test suite)\n- Phase 2 (Implementation): 3-4 hours (implement to pass tests)\n- Phase 3 (Validation): 1 hour (backward compat verification)\n- Phase 4 (Integration): 1 hour (docs + final testing)\n\n**Total: ~8 hours of focused TDD development**\n\n---\n\n## Acceptance Criteria\n\n✅ All tests passing (100%)\n✅ Can read existing Julie checkpoints\n✅ Julie can read Miller checkpoints (manual verification)\n✅ Same JSON schema, file structure, naming conventions\n✅ Git context captured correctly\n✅ Plans work with single-active enforcement\n✅ Documentation complete\n✅ Ready to dogfood Miller as Julie replacement",
  "git": {
    "branch": "main",
    "commit": "cf00e54713e1dc020a03e168808f1cf3523fc518",
    "dirty": false
  }
}